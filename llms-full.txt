# Getting Started

import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Step, Steps } from 'fumadocs-ui/components/steps'

## Installation

Run one of the following commands to add React MVVM and all needed libraries:

<Tabs items={['npm', 'yarn', 'pnpm']}>
  <Tab value="npm">
    `bash npm install react-mvvm mobx mobx-react reflect-metadata `
  </Tab>

  <Tab value="yarn">
    `bash yarn add react-mvvm mobx mobx-react reflect-metadata `
  </Tab>

  <Tab value="pnpm">
    `bash pnpm add react-mvvm mobx mobx-react reflect-metadata `
  </Tab>
</Tabs>

## Preparation

You must import `reflect-metadata` in your main script file so that you can use the decorators. You can also configure this package, but this step is optional.

<Steps>
  <Step>
    Import reflect-metadata in your main entry file:

    ```typescript
    import 'reflect-metadata';
    import { configure } from 'react-mvvm';
    import { createRoot } from 'react-dom/client';

    // Optional step
    configure({
      // Configuration options
    });

    createRoot(document.getElementById('root')!).render(<App />);
    ```
  </Step>

  <Step>
    You can use `mobx` with versions **4, 5 or 6**. And it's recommended to use the 6th one.

    In case you want to use versions 4 or 5 you should add the following code to your webpack configuration:

    ```javascript
    module.exports = {
      // ...
      ignoreWarnings: [
        {
          module: /react-mvvm/,
        },
      ],
      // ...
    };
    ```
  </Step>
</Steps>

## Usage

You can find examples of using this package in [the examples section](/examples).

## Further reading

Despite the fact that React MVVM is an extremely small library, it can greatly affect the development process. For a better understanding of the beauty of this library, we advise you to read an [article about MobX and MVVM](https://dev.to/yoskutik/mobx-with-mvvm-makes-frontend-developers-life-much-more-easier-than-redux-does-547j).


# Changelog

<Updates>
  <Update label="1.1.3 - 2022-11-15">
    ### Changed \[!toc]

    * Fields `parent` and `viewProps` now are not `undefined` during the first view render.
  </Update>

  <Update label="1.2.0 - 2022-12-26">
    ### Changed \[!toc]

    * Fields `parent` and `viewProps` now are not `undefined` in the constructor of view model;
    * Due to the fact above `parent` is no more observable;
    * Field `parent` now can be typed as `null` in case there's no parent view model;
    * Returned functions of `view` and `childView` now have 2 generics - for typing props and
    * forwarded ref. Now, it is better to use these generics rather explicitly typing props via `FC`:

    ```tsx
    // Before
    const View: FC<Props> = view(SomeViewModel)(() => (
      <div />
    ));

    // After
    const View = view(SomeViewModel)<Props>(() => (
      <div />
    ));
    ```

    * The README file is now consist of a minimal example. The documentation can be found on the
    * [website](https://beautyfree.github.io/react-mvvm/).

    ### Removed \[!toc]

    * Type `ViewWithRef` was removed. To type forwarded ref of view or child view you can now use
    * the second generic of these functions:

    ```tsx
    // Before
    const View: ViewWithRef<HTMLDivElement, Props> = view(SomeViewModel)(() => (
      forwardRef(() => <div />)
    ));

    // After
    const View = view(SomeViewModel)<Props, HTMLDivElement>(() => (
      forwardRef(() => <div />)
    ));
    ```

    * Removed an idle render of view components for initializing `parent` and `viewProps` fields.
  </Update>

  <Update label="1.2.1 - 2023-01-08">
    ### Changed \[!toc]

    * The size of the packages was reduces from 1.8Kb to 1.6Kb
  </Update>
</Updates>


# Changelog

<Updates>
  <Update label="1.1.3 - 2022-11-15">
    ### Changed \[!toc]

    * Fields `parent` and `viewProps` now are not `undefined` during the first view render.
  </Update>

  <Update label="1.2.0 - 2022-12-26">
    ### Changed \[!toc]

    * Fields `parent` and `viewProps` now are not `undefined` in the constructor of view model;
    * Due to the fact above `parent` is no more observable;
    * Field `parent` now can be typed as `null` in case there's no parent view model;
    * Returned functions of `view` and `childView` now have 2 generics - for typing props and
    * forwarded ref. Now, it is better to use these generics rather explicitly typing props via `FC`:

    ```tsx
    // Before
    const View: FC<Props> = view(SomeViewModel)(() => (
      <div />
    ));

    // After
    const View = view(SomeViewModel)<Props>(() => (
      <div />
    ));
    ```

    * The README file is now consist of a minimal example. The documentation can be found on the
    * [website](https://beautyfree.github.io/react-mvvm/).

    ### Removed \[!toc]

    * Type `ViewWithRef` was removed. To type forwarded ref of view or child view you can now use
    * the second generic of these functions:

    ```tsx
    // Before
    const View: ViewWithRef<HTMLDivElement, Props> = view(SomeViewModel)(() => (
      forwardRef(() => <div />)
    ));

    // After
    const View = view(SomeViewModel)<Props, HTMLDivElement>(() => (
      forwardRef(() => <div />)
    ));
    ```

    * Removed an idle render of view components for initializing `parent` and `viewProps` fields.
  </Update>

  <Update label="1.2.1 - 2023-01-08">
    ### Changed \[!toc]

    * The size of the packages was reduces from 1.8Kb to 1.6Kb
  </Update>
</Updates>


# ChildView

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

## Overview

As the `view`, the `childView` function creates an object that also implements the view logic from the MVVM pattern. But there's a big difference in these functions - ChildView does not call `vmFactory` and uses a view's view model as own one.

By default, every child view is an observer and is memoized. And you can change it. The options of creating view child is same as for view.

## Usage

```typescript
childView()(Component[, options])
```

See using ChildView: [Example](/docs/examples/basic-examples#using-childview).

### Options

See setting options: [Example](/docs/examples/basic-examples#setting-options).

## Usage Example

```typescript
import React from 'react'
import { childView } from 'react-mvvm'
import type { SomeViewModel } from './path-to-view-model'

export type Props = {
  prop1: number
  prop2?: string
}

export const SomeChildView = childView<SomeViewModel>()<Props>(
  ({ viewModel, prop1, prop2 }) => (
    <div>
      {viewModel.field1}
      {prop1}
      {prop2}
    </div>
  )
)
```

***

## ChildViewComponent

We highly recommend using React MVVM with functional style components. But to increase compatibility, we added a class `ChildViewComponent`, so you can create instances of ChildView as class components.

<Callout type="info">
  If you want to create an instance of View as class component, please see the
  [example](/docs/examples/basic-examples#using-class-components).
</Callout>

The only difference between class-style ChildView and functional-style ChildView is that in the class-style `viewModel` field is part of class, while in the function-style it's a property. And since functional-style child views are declared with `memo`, `ChildViewComponent` is extended from `PureComponent`.

### Usage Example

```typescript
import React from 'react'
import { ChildViewComponent } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

export type Props = {
  prop1: number
  prop2?: string
}

class SomeChildView extends ChildViewComponent<SomeViewModel, Props> {
  render() {
    return (
      // viewModel is a class member, not a property of the component
      <div>{this.viewModel.field1}</div>
    )
  }
}
```


# Configuration

## Overview

This library can be configured at the global level.

## Usage

```typescript
configure({ vmFactory, Wrapper })
```

#### `vmFactory`

This function tells the view how to create an instance of a view model. By default, all view models are simply creating with a `new` keyword.

See configuring vmFactory: [Example](/docs/examples/basic-examples#configuring-vmfactory).

#### `Wrapper`

A wrapper which is used in `view` and `childView`. By default, `Wrapper` is equal to `React.Fragment`. The wrapper is useful if you want to add an ErrorBoundary or for a debugging purposes.

See configuring the wrapper: [Basic usage](/docs/examples/basic-examples#configuring-wrapper), [Error Boundary](/docs/examples/useful-examples#using-error-boundary).

## Usage sample

```typescript
import { FC, ReactElement } from 'react'
import { configure } from 'react-mvvm'

const CustomWrapper: FC<{ children: ReactElement }> = ({ children }) => {
  // do anything you want
  return (
    <div>
      You can also add JSX
      {children}
    </div>
  )
}

configure({
  vmFactory: (VM) => {
    const viewModel = new VM()
    // do anything you want
    return viewModel
  },
  Wrapper: CustomWrapper,
})
```


# Core Concepts

import { Cards, Card } from 'fumadocs-ui/components/card'

## Overview

React MVVM implements the MVVM (Model-View-ViewModel) pattern for React applications. The main components are:

<Cards>
  <Card title="View" href="/docs/core-concepts/view">
    Creates components that display data and handle user interactions
  </Card>

  <Card title="ChildView" href="/docs/core-concepts/childview">
    Reuses parent ViewModel without creating new instances
  </Card>

  <Card title="ViewModel" href="/docs/core-concepts/viewmodel">
    Stores observable fields and logic for updating them
  </Card>

  <Card title="Configuration" href="/docs/core-concepts/configuration">
    Global configuration for ViewModel factories and wrappers
  </Card>
</Cards>


# View

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

## Overview

The `view` function creates an object that implements the view logic from the MVVM pattern. This means that view should be responsible for displaying a component in your application.

A view takes a `vmFactory` from the `configuration` and call it to create an instance of a view model. Also view is responsible for updating view model's fields `parent` and `viewProps` and for calling view's lifecycle hooks in the instance of a view model.

By default, every view is an observer. But you can configure it.

<Callout>
  One of the issues that solves this package is the purity of the code. The
  fewer props your components have, the easier it will be to understand your
  code for others. And with this package you can minimize amount of props passed
  by observing view model's fields, its parent's fields and so on. For example,
  a ChildView can observe its View props.
</Callout>

**Every view is memoized**. And as it states below, the fewer props your view having, the faster your application will work. Since the view uses `memo` function, you can also pass the `propsAreEqual` function to it.

## Usage

```typescript
view(SomeViewModel)(Component[, options])
```

### Options

There are two options: `observer` and `propsAreEqual`. If `observer` is `false`, when view will be created as non-observer component. And if `propsAreEqual` is set, it will be passed to a `memo` function (See [how memo works](https://reactjs.org/docs/react-api.html#reactmemo) for better understanding).

See setting view options: [Example](/docs/examples/basic-examples#setting-options).

## Usage Example

```typescript
import React from 'react'
import { view } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

export type Props = {
  prop1: number
  prop2?: string
}

export const SomeView = view(SomeViewModel)<Props>(
  ({ viewModel, prop1, prop2 }) => (
    <div>
      {viewModel.field1}
      {prop1}
      {prop2}
    </div>
  )
)
```


# ViewModel

import { Cards, Card } from 'fumadocs-ui/components/card'

## Overview

The `ViewModel` class is an object that implements the view model logic from the MVVM pattern. In general case, the `ViewModel` is designed to store observable fields, as well as logic for updating them.

The `ViewModel` stores a reference to the props object with which the view was rendered with and also a reference to the parent view model. Also, `ViewModel` has a few view's lifecycle methods.

## What is `parent` for a ViewModel?

The assignment of the parent view model occurs according to the virtual DOM tree. If `View2` is located somewhere inside `View1`, then `ViewModel1` will be considered the parent of `ViewModel2`.

## Properties

#### `@observable.ref readonly parent`

A link to a parent view model.

See typing and using parent view model: [Example](/docs/examples/basic-examples#typing-parent-and-viewprops).

#### `@observable.ref readonly viewProps`

A link to a props the view has rendered with. Every time the view is renders it updates this field. Every view is memoized, and this mean that this object will be updated only if at least 1 property has been changed.

<Callout type="warn">
  Be careful observing `viewProps`. If some of yours observer components or
  reactions are using `viewProps`, they might update every time any prop has
  changed, even if the updated prop is not used directly. For better
  understanding of how you should observe the props, please, see the example.
</Callout>

See typing, using and observing viewProps: [Example](/docs/examples/basic-examples#observing-viewprops).

## Methods

### Lifecycle Methods

#### `protected onViewMounted?()`

A hook which is called after the view becomes mounted. The function is called in the `useEffect` hook.

#### `protected onViewUpdated?()`

A hook which is called after the view is rendered besides the first render. This function is called in the `useEffect` hook.

#### `protected onViewUnmounted?()`

A hook which is called after the view becomes unmounted. The function is called in the `useEffect` hook.

#### `protected onViewMountedSync?()`

A hook which is called after the view becomes mounted. The function is called in the `useLayoutEffect` hook.

#### `protected onViewUpdatedSync?()`

A hook which is called after the view is rendered besides the first render. This function is called in the `useLayoutEffect` hook.

#### `protected onViewUnmountedSync?()`

A hook which is called after the view becomes unmounted. The function is called in the `useLayoutEffect` hook.

See using view hooks: [Example](/docs/examples/basic-examples#view-lifecycle-hooks).

### Reactions and Disposers

#### `protected autorun(...args)`

An add-on function for an `autorun` from MobX. When view becomes unmounted, the disposer of this function will be called automatically.

#### `protected reaction(...args)`

An add-on function for a `reaction` from MobX. When view becomes unmounted, the disposer of this function will be called automatically.

#### `protected addDisposer(disposer)`

A function which adds a disposer that will be called after the view becomes unmounted.

<Callout type="warn">
  MobX states that **you should always dispose of reactions**. This is why
  `autorun`, `reaction` and `addDisposer` were added to a `ViewModel`. So,
  please, use it every time you want to create reactions *inside a view model*.
  Otherwise, you can create a memory leak.
</Callout>

See observing: [Example](/docs/examples/basic-examples#creating-reactions).

## Usage Example

```typescript
import { ViewModel } from 'react-mvvm'
import { action, observable, makeObservable } from 'mobx'
import type { ParentViewModel } from '../path-to-parent-view-model'
import type { Props } from './path-to-view'

export class SomeViewModel extends ViewModel<ParentViewModel, Props> {
  @observable field1 = 0
  @observable field2 = 'field'

  constructor() {
    super()
    makeObservable(this)
  }

  protected onViewMounted() {
    // do something
  }

  @action doSomething = () => {
    // do something
  }
}
```


# Basic Examples

import { Cards, Card } from 'fumadocs-ui/components/card'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

## Basic Examples

This section contains examples of basic usage of entities with all possible typings and variants.

<Cards>
  <Card title="View and ChildView" href="#view-and-childview">
    Learn how to create and configure views and child views
  </Card>

  <Card title="ViewModel" href="#viewmodel">
    Understand ViewModel lifecycle, reactions, and parent-child relationships
  </Card>

  <Card title="Configuration" href="#configuration">
    Configure ViewModel factories and wrappers globally
  </Card>
</Cards>

## View and ChildView

The interfaces of `view` and `childView` are pretty much the same. The only difference - the way the view model is typed.

### Using `childView`

The component which was created with `childView` must be used somewhere inside a view of the same view model.

```typescript
import React from 'react'
import { view, childView } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

export const ChildView = childView<SomeViewModel>()(({ viewModel }) => <div />)

// ChildView does not create a view model and should be located somewhere inside a view.
// Thus, it can use view's view model.
export const View1 = view(SomeViewModel)(({ viewModel }) => <ChildView />)

// It doesn't have to be the direct child
export const View2 = view(SomeViewModel)(({ viewModel }) => (
  <div>
    <ChildView />
  </div>
))
```

### Typing props

By default, `view` and `childView` returns an `FC` component with no props. But you can type it using `FC` type.

```typescript
import React from 'react'
import { view, childView } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

// View1 and ChildView1 don't have any props
export const View1 = view(SomeViewModel)(({ viewModel }) => <div />)
export const ChildView1 = childView<SomeViewModel>()(({ viewModel }) => <div />)

// The lines below will not be compiled
// <View1 viewModel={...} />
// <ChildView1 viewModel={...} />

export type Props = {
  prop1: number // A required prop
  prop2?: string // An optional prop
}

export const View2 = view(SomeViewModel)<Props>(
  ({ viewModel, prop1, prop2 }) => <div />
)

export const ChildView = childView<SomeViewModel>()<Props>(
  ({ viewModel, prop1, prop2 }) => <div />
)

// And now you can pass the props
// <View2 prop1={2} prop2="prop2" />
// <ChildView2 prop1={2} prop2="prop2" />
```

### Setting options

By default, `view` and `childView` create a memoized observer component. You can make it non-observer or pass `propsAreEqual` function to the `memo` HOC.

```typescript
import React from 'react'
import { view, childView } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

// View1 and ChildView1 are observers and they are memoized
export const View1 = view(SomeViewModel)(({ viewModel }) => <div />)
export const ChildView1 = childView<SomeViewModel>()(({ viewModel }) => <div />)

// View2 and ChildView2 are not observers now, but they still memoized with default behaviour
export const View2 = view(SomeViewModel)(({ viewModel }) => <div />, {
  observer: false,
})
export const ChildView2 = childView<SomeViewModel>()(
  ({ viewModel }) => <div />,
  { observer: false }
)

type Props = {
  prop1: number
}

const propsAreEqual = (prevProps: Props, nextProps: Props) => {
  // logic here
}

// And this is how you can change propsAreEqual function for the memo
export const View3 = view(SomeViewModel)<Props>(({ viewModel }) => <div />, {
  propsAreEqual,
})
export const ChildView3 = childView<SomeViewModel>()<Props>(
  ({ viewModel }) => <div />,
  { propsAreEqual }
)
```

### Using `forwardRef`

Of course, there's an opportunity to pass a ref via `view` and `childView`. You just need to apply `forwardRef` before applying these functions. Also, if you want to type the component, you have to use second generic.

```typescript
import React, { forwardRef } from 'react'
import { view, childView } from 'react-mvvm'
import { SomeViewModel } from './path-to-view-model'

// Only ref with no props
export const View1 = view(SomeViewModel)<unknown, HTMLDivElement>(
  forwardRef(({ viewModel }, ref) => <div ref={ref} />)
)

export const ChildView1 = childView<SomeViewModel>()<unknown, HTMLDivElement>(
  forwardRef(({ viewModel }, ref) => <div ref={ref} />)
)

type Props = {
  prop1: number
}

// With props
export const View2 = view(SomeViewModel)<Props, HTMLDivElement>(
  forwardRef(({ viewModel, prop1 }, ref) => <div ref={ref} />)
)

export const ChildView2 = childView<SomeViewModel>()<Props, HTMLDivElement>(
  forwardRef(({ viewModel, prop1 }, ref) => <div ref={ref} />)
)
```

### Using class components

We do not recommend writing new code with class-style components. However, we give you the opportunity to use the MVVM pattern for class components as well. A class component can't be a view, only a ChildView. However, you can additionally use the `view` function to wrap your ChildView to make it act as view.

```typescript
import { ChildViewComponent, view } from 'react-mvvm'
import { SomeViewModel } from './SomeViewModel'

type Props = {
  prop1: number
}

// This is a child view. It should be used somewhere inside a view with SomeViewModel view model
export class SomeChildView extends ChildViewComponent<SomeViewModel, Props> {
  render() {
    return <div>{this.viewModel.field}</div>
  }
}

// But if you want to make it act as view, you can wrap it with the view function
export default view(SomeViewModel)<Props>((props) => (
  <SomeChildView {...props} />
))
```

## ViewModel

### Typing `parent` and `viewProps`

View models have link to their parents and also have link to view's props. And you can type both of these fields.

```typescript
import { ViewModel } from 'react-mvvm'
import type { ParentViewModel } from './ParentViewModel'
import type { Props } from './path-to-view-props'

// No typings. parent is unknown, viewProps is unknown
export class SomeViewModel1 extends ViewModel {}

// Parent is ParentViewModel, viewProps is unknown
export class SomeViewModel2 extends ViewModel<ParentViewModel> {}

// Parent is ParentViewModel, viewProps is Props
export class SomeViewModel3 extends ViewModel<ParentViewModel, Props> {}

// Parent is unknown, viewProps is Props
export class SomeViewModel4 extends ViewModel<unknown, Props> {}
```

### Using `parent`

If a view is located somewhere inside another view, inner view can use outer one's view model.

```typescript
import { view, ViewModel } from 'react-mvvm'

class ViewModel1 extends ViewModel {
  doSomething = () => {}
}

class ViewModel2 extends ViewModel<ViewModel1> {
  onClick = () => {
    this.parent.doSomething()
  }
}

// View2 must be located somewhere inside View1. Thus, view model of View1 will be a parent view model for View2
const View2 = view(ViewModel2)(({ viewModel }) => (
  <button onClick={viewModel.onClick} />
))

const View1 = view(ViewModel1)(({ viewModel }) => (
  <div>
    <View2 />
  </div>
))
```

### Observing `viewProps`

The `viewProps` field updates every time the view is rendered with new props. The view is memoized, so the amount of updates is minimized. But you need to keep in mind a few rules when you want to observe `viewProps`. If you are using `viewProps` inside an `autorun` or an observer component (`observer`, `view` or `childView`), when the reaction will be called every time the view is rendered with new props.

```typescript
import { computed, makeObservable } from 'mobx'
import { view, childView, ViewModel } from 'react-mvvm'

type Props = {
  prop1: number
  prop2: string
}

export class SomeViewModel extends ViewModel<unknown, Props> {
  @computed get prop1() {
    return this.viewProps.prop1
  }

  constructor() {
    super()
    makeObservable(this)

    // This autorun will be called every time the view gets any new prop, even if the prop1 didn't change
    this.autorun(() => {
      console.log(this.viewProps.prop1)
    })

    // This reaction will be called only if the prop has changed
    this.reaction(
      () => this.viewProps.prop1,
      () => {
        console.log(this.viewProps.prop1)
      }
    )

    // This autorun will be called only if the prop has changed
    this.autorun(() => {
      console.log(this.prop1)
    })
  }
}

const SomeChildView = childView<SomeViewModel>()(({ viewModel }) => (
  <div>
    {/* If you use the line below, SomeChildView will be re-rendered every time SomeView get any new prop */}
    {viewModel.viewProps.prop1}

    {/* If you use the line below, SomeChildView will be re-rendered only if prop1 was changed */}
    {viewModel.prop1}
  </div>
))

const SomeView = view(SomeViewModel)<Props>(() => <SomeChildView />)
```

### View lifecycle hooks

You add handle some of the view lifecycle state changes, such as mounting, unmounting and updating. There are 3 methods for each hook in the `ViewModel`.

```typescript
import { ViewModel } from 'react-mvvm'

// Hooks can be sync and async. Also, they can be decorated with @action or other decorators
export class SomeViewModel extends ViewModel {
  protected onViewMounted() {
    console.log(
      'View has been mounted. This function is called in the useEffect hook'
    )
  }

  protected onViewMountedSync() {
    console.log(
      'View has been mounted. This function is called in the useLayoutEffect hook'
    )
  }

  protected onViewUpdated() {
    console.log(
      'View has been updated. This function is called in the useEffect hook'
    )
  }

  protected onViewUpdatedSync() {
    console.log(
      'View has been updated. This function is called in the useLayoutEffect hook'
    )
  }

  protected onViewUnmounted() {
    console.log(
      'View has been unmounted. This function is called in the useEffect hook'
    )
  }

  protected onViewUnmountedSync() {
    console.log(
      'View has been unmounted. This function is called in the useLayoutEffect hook'
    )
  }
}
```

### Creating reactions

To observe anything in a view model, you *should* use ViewModel's `reaction`, `autorun` and `addDisposer` methods. These methods are added to automatically dispose reactions, when the view becomes unmounted. You can also not to use these methods, but in these case there can be a probability of a memory leak formation.

```typescript
import { intercept, makeObservable, observable, observe, when } from 'mobx'
import { ViewModel } from 'react-mvvm'

export class SomeViewModel extends ViewModel {
  @observable field = 0

  constructor() {
    super()
    makeObservable(this)

    // If you want to create a reaction, please, use this.reaction instead of reaction from the mobx package
    this.reaction(
      () => this.field,
      (value) => this.doSomething(value)
    )

    // If you want to create an autorun, please, use this.reaction instead of reaction from the mobx package
    this.autorun(() => {
      this.doSomething(this.field)
    })

    // In case you want to create other type of observation, such as observe, intercept or when, you can use
    // this.addDisposer

    // observe
    this.addDisposer(
      observe(this, 'field', ({ newValue }) => this.doSomething(newValue))
    )

    // intercept
    this.addDisposer(
      intercept(this, 'field', (change) => {
        this.doSomething(change.newValue)
        return change
      })
    )

    // when
    const w = when(() => this.field === 1)
    w.then(() => this.doSomething(this.field))
    this.addDisposer(() => w.cancel())
  }

  doSomething = (field: number) => {}
}
```

## Configuration

### Configuring `vmFactory`

`vmFactory` tells to views how they should create an instance of a view model. You can configure this function to add debug information or a middleware.

```typescript
import { configure } from 'react-mvvm'

configure({
  vmFactory: (VM) => {
    // By default, vmFactory returns new VM();

    const viewModel = new VM()

    // But you can do anything here
    // Add debug information
    console.log('view model created:', viewModel)

    // Or process your view model somehow
    ;(viewModel as any).__some_special_field = 'some special value'

    // vmFactory must return an instance of a ViewModel
    return viewModel
  },
})
```

### Configuring `Wrapper`

The `Wrapper` is used to wrap all the views and childViews. By default, the `Wrapper` is equal to `React.Fragment` so it doesn't really affect on your application. But you can set any component as wrapper to add debug information or a middleware.

```typescript
import { configure } from 'react-mvvm'
import { Component, FC, ReactElement } from 'react'

// The Wrapper can be declared both with functional style or as class
// It must have children as a prop, at it should return a children. Otherwise, your views will not be shown.
const FunctionalWrapper: FC<{ children: ReactElement }> = ({ children }) => {
  // You can add a debug info
  console.log('view is rendered')

  // You should return children
  return children
}

// You can also use class components
class ClassWrapper extends Component<{ children: ReactElement }> {
  render() {
    // You can also return processed children
    return (
      <div>
        <span>Wrapper content</span>
        {this.props.children}
      </div>
    )
  }
}

configure({
  Wrapper: FunctionalWrapper,
})

configure({
  Wrapper: ClassWrapper,
})
```


# Complex Examples

## Complex Examples

And here's some complex examples of whole React applications with React MVVM. You can find them here [Github](https://github.com/beautyfree/react-mvvm/tree/master/examples).


# Examples

import { Cards, Card } from 'fumadocs-ui/components/card'

## Overview

This section contains comprehensive examples and patterns for using React MVVM in your applications. From basic usage to advanced patterns and real-world use cases.

<Cards>
  <Card title="Basic Examples" href="/docs/examples/basic-examples">
    Learn the fundamentals with View, ChildView, and ViewModel examples
  </Card>

  <Card title="Complex Examples" href="/docs/examples/complex-examples">
    Explore complete React applications built with React MVVM
  </Card>

  <Card title="Useful Examples" href="/docs/examples/useful-examples">
    Discover helpful patterns and tricks to enhance your development workflow
  </Card>
</Cards>


# Useful Examples

## Useful Examples

This section contains some tricks that can simplify you development process.

### Automatic `makeObservable`

If you sure that most case your view models will contain observable fields you can make calling `makeObservable` automatic, so you don't need to call it for each ViewModel separately. But be aware, if you use this code, you should create your reactions in the `onViewMounted` hook instead of constructor due to the fact that view model will not be observable in it.

```typescript
import { makeObservable, observable } from 'mobx'
import { configure, ViewModel } from 'react-mvvm'

configure({
  vmFactory: (VM) => {
    const viewModel = new VM()
    makeObservable(viewModel)
    return viewModel
  },
})

class SomeViewModel extends ViewModel {
  @observable field1 = 0

  protected onViewMounted() {
    // In case you make view models observable in a vmFactory, and you want to create reactions,
    // you should do it in the hook
    this.reaction(
      () => this.field1,
      () => {
        // do something
      }
    )
  }
}
```

### Enabling DI pattern

I really like the DI pattern. And I highly recommend you to use this pattern if you application is big. This pattern can have a big impact on the ability to scale your application. With the DI you can create common MobX stores for whole application. Such Redux does, but with DI + MobX these stores can be logically separated, can contain methods and can be easily used at any part of your code, including both views and view models.

```typescript
import { computed, makeObservable, observable } from 'mobx'
// It's not necessary to use tsyringe. You can use any library actually
import { injectable, container, singleton } from 'tsyringe'
import { configure, ViewModel } from 'react-mvvm'

configure({
  vmFactory: (VM) => container.resolve(VM),
})

// This is an example of common store for the whole application
@singleton()
class SomeOuterClass {
  @observable field1 = 0

  @observable field2 = 'field2'

  constructor() {
    makeObservable(this)
  }

  doSomething = () => {
    // do something
  }
}

// It can also be any singleton or transient class, containing observable fields is not necessary
@injectable()
class SomeOuterClass2 {
  @observable field1 = 0

  @observable field2 = 'field2'

  constructor(private someOuterClass: SomeOuterClass) {
    makeObservable(this)
  }

  doSomething = () => {
    // do something
  }
}

@injectable()
class SomeViewModel extends ViewModel {
  @computed get someGetter() {
    return this.someOuterClass.field1
  }

  // And now every ViewModel can access the class via constructor
  constructor(
    private someOuterClass: SomeOuterClass,
    private someOuterClass2: SomeOuterClass2
  ) {
    super()
    makeObservable(this)
  }

  viewModelFunction = () => {
    this.someOuterClass.doSomething()
  }
}

// You can also get an instance of singleton class in the any place of your code
const instance = container.resolve(SomeOuterClass)
```

### Using Error Boundary

React applications have a few problems. One of them is error handling. If some of your component throws an error and you don't handle it, all the virtual DOM tree will die. FaceBook recommends to use ErrorBoundary to handle such errors. But it can be inconvenient to use it - you should always think where to use it, and there can be a lot of repeating code of using the same error boundary. But with this package you can add error boundaries to all of your views and childViews, so you don't actually have to think about using it at all.

```typescript
import { Component, ReactElement } from 'react'
import { configure } from 'react-mvvm'

class ErrorBoundary extends Component<
  { children: ReactElement },
  { hasError: boolean }
> {
  static getDerivedStateFromError() {
    return { hasError: true }
  }

  state = {
    hasError: false,
  }

  componentDidCatch(error: Error) {
    // I recommend you to log the error to avoid situations where your content is disappeared,
    // and you don't know the reason
    console.error(error)
  }

  render() {
    return !this.state.hasError && this.props.children
  }
}

configure({
  // That's it. And now if one of your components throws an error it will just disappear. At it
  // will be the only component that disappeared.
  Wrapper: ErrorBoundary,
})
```

## Complex Examples

And here's some complex examples of whole React applications with React MVVM. You can find them here [Github](https://github.com/beautyfree/react-mvvm/tree/master/examples).
